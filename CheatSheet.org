#+TITLE: OCaml Cheat Sheet
# SUBTITLE: Getting Started Reference Sheet
#+MACRO: URL https://github.com/alhassy/OCamlCheatSheet
#+MACRO: ShowURL @@latex:{\tiny\hspace{6em}\url{ {{{URL}}} } }@@
#+AUTHOR: [[http://www.cas.mcmaster.ca/~alhassm/][Musa Al-hassy]] {{{ShowURL}}}
#+EMAIL: alhassy@gmail.com
#+TODO: TODO | spacing
#+OPTIONS: d:nil
#+INCLUDE: CheatSheet/CheatSheetSetup.org

# The OCaml toplevel, version 4.07.1

* Administrivia :ignore:

OCaml is a strict language;
it is strongly typed where types are inferred.

I may write explicit type annotations below for demonstration
or clarity purposes.
  #+BEGIN_SRC ocaml
  (* Using explicit type annotations *)
  let x : int = 3;;
  let f (x : int) (y : string) (r : 'a) : float = 3.14;;
#+END_SRC

Only when interacting with the top-level interpreter,
commands must be terminated by ~;;~.
OCaml uses ~;~ as an expression /separator/ ---not a terminator!

My Emacs setup for OCaml can be found on this [[https://github.com/alhassy/OCamlCheatSheet][CheatSheet's repo]].
* COMMENT more Administrivia

+ Command line interpreter, REPL, begun with ~ocaml~ and exited with ~exit 0;;~
  - All expressions in REPL must be terminated with ~;;~, not so in a script.
     #+BEGIN_EXAMPLE
# let rec x = 4 and woah (a, b) c = print_endline a ; print_endline b; x + c ;;
val x : int = 4
val woah : string * string -> int -> int = <fun>

# woah ("currying", "or not") 12 ;
currying
or not
- : int = 16
#+END_EXAMPLE

     Note the keywords for mutual recursion: ~let rec ... and ...~.

  - To load a source file enter ~#use "myfile.ml;;"~.

+ Only multi-line, nestable, comments: ~(* ... *)~.

+ All declarations are preceded by ~let~ or ~let rec~ for recursive ones.

+ Sequencing is via ~;~ and the result is the value of the final expression.

+ Anonymous functions use the syntax: ~fun x₀ … xₙ -> ...~
  - ~function~ in-place of ~fun~ also works.
  - Infix functions can be used in prefix by enclosing them in parens; e.g., ~(+) 1 2.~

* TODO COMMENT Emacs Setup
#+BEGIN_SRC emacs-lisp
(use-package tuareg) ;; Emacs’ OCaml mode

;; The OCaml package manager: https://opam.ocaml.org/
(async-shell-command "brew install opam") ;; version 2.0.4
(async-shell-command "opam switch create 4.07.1") ;; install ocaml
; (async-shell-command "brew install ocaml")

;; Feature-rich full replacement to OCaml's standard library
(async-shell-command "time opam install base stdio")
;; This may appear to ‘hang’, but that's because it took me 13 minutes.
#+END_SRC

Ensuring libraries are loaded in toplevel ocaml sessions; the following is my
~~/.ocamlinit~.
#+BEGIN_SRC ocaml :tangle (when nil "~/.ocamlinit")
(* Added by OPAM. *)
  try Topdirs.dir_directory (Sys.getenv "OCAML_TOPLEVEL_PATH")
  with Not_found -> ();;

#use "topfind";;
#thread;;
#require "base";;
open Base;;
#+END_SRC
#require "core.top";;
#require "core.syntax";;

#+BEGIN_SRC ocaml
  let ratio1 x y = let open Float.O in of_int x / of_int y;;
#+END_SRC

Let's obtain ~ocp-indent~ ---OCaml's indentation tool that indents the same even if
co-workers use a different editor--- and [[https://github.com/ocaml/merlin/wiki/emacs-from-scratch][merlin]] which provides interactive feedback
including context-aware completion and jumping to definitions.
#+BEGIN_SRC emacs-lisp
(async-shell-command "time opam install ocp-indent merlin") ;; real 1m33.636s
(use-package merlin)
(add-hook 'tuareg-mode-hook #'merlin-mode)

(with-eval-after-load 'merlin
  (setq merlin-command 'opam))
#+END_SRC
Now entering, say,
@@latex:\texttt{List.}\null{}@@ brings a pop-up compleition menu for the
contents of the list module.
#+latex: \hfill
---In org-src blocks, you need to enter the ocaml mode, via ~C-c '~.
# Or simple “M-x merline-mode” to use it /anywhere/, since it's a minor mode. :smile:
# The latter is not ideal since it can radically slow down literate writing.

:More:
+ C-c C-t :: Obtain type of OCaml identifier.

#+BEGIN_SRC ocaml
type nin = int;;
let x : nin = 1;;

x
#+END_SRC

#+RESULTS:
: 1

On ~x~, one ~C-c C-t~ yields ~nin~, further invocations improve verbosity by expanding
aliases to obtain ~int~.

+ Use ~merlin-type-expr~ to obtain the type of a given expression.
+ Use ~C-c C-l~ to jump to definition; ~merlin-locate~.

See here for more: https://github.com/ocaml/merlin/wiki/emacs-from-scratch
:End:

* Arithmetic
  Operations on floats have a ‘.’ suffix.
  #+BEGIN_SRC ocaml
  8 / 3;;      (* 2 *)
  8 /. 3;;     (* Type error: /. is for floats *)
  8.0 /. 3.0;; (* 2.6666… *)
#+END_SRC

* Functions & Variables
A function is declared with the ~let~ keyword
---variables are functions of zero arguments.

\room
Function & varaible names /must/ begin with a lowercase letter, and may use _ or ~'~.
+ They cannot begin with capital letters or numbers, or contain dashes!
+ Functions are like variables, but with arguments, so the same syntax applies.

#
#+begin_parallel org
#+BEGIN_SRC ocaml
(* A curried function *)
let f x y = x + y

(* Function application *)
let result = f 10 (2 * 6)

(* Partial application *)
let g x = f x 2
#+END_SRC

#+latex: \columnbreak

#+BEGIN_SRC ocaml
(* We can re-bind variables *)
let x = 123
let x = string_of_int x
#+END_SRC

Recursive functions are marked with the ~rec~ keyword.
#+BEGIN_SRC ocaml
let rec fact n = if n = 0
		 then 1
		 else n * fact (n - 1)
#+END_SRC

#+end_parallel

 Here's an example of a higher-order function & multiple local functions
 & an infix operator & an anonymous function & the main method is
 parametricly polymorphic.
 that contains & a local function & anonymous function.
#+BEGIN_SRC ocaml
let try_add (bop : 'a -> 'a -> 'a) (test : 'a -> bool)
	    (default : 'a) (x : 'a) (y : 'a)
   = let (/@/) x y = bop x y
     (* Only select symbols can be used as infix operators *)
     (* (/@/) x y  =  x /@/ y *)
     and wrap a = if test a then a else default
     in wrap x /@/ wrap y;;

  699 = try_add (+) (fun a -> a mod 3 = 0) (666) (~-1) 33;;
  (* The anonymouse function uses ‘=’ as Boolean equality. *)

  ~- 2 = ~- 2 mod 3;; (* /Remainder/ after dividing out 3s *)
#+END_SRC


#+BEGIN_SRC ocaml :session
(* Unit type; usage: my_io () *)
let my_io () = print_endline "Hello World!" ;;
#+END_SRC

OCaml is a functional language: /Procedures/ are functions
returning the unit type.

A /function/ is a sequence of expressions; its /return value/
is the value of the final expression ---all other expressions
are of unit type.

#+BEGIN_SRC ocaml :session
let const x y
  = my_io();
    y;
    x

let res = const 1972 12
#+END_SRC

* TODO COMMENT Using Modules
I could not get the Base library to work nicely with everything :'(

 Modules names always begin with a capital; their contents are accessed with
     dot notation.

#+BEGIN_SRC ocaml
  (* The following three are typed int → int → float *)
  let ratio0 x y = Float.of_int x /. Float.of_int y;;
  (* Let's locally use the Float.O library to overshadow the standard int-only operators. *)
  let ratio1 x y = let open Float.O in of_int x / of_int y;;
  (* Let's be even more terse *)
  let ratio2 x y = Float.O.(of_int x / of_int y);;
#+END_SRC

* Booleans
 Inequality is expressed with ~<>~.
#+BEGIN_SRC ocaml
(* false, true, false, true, false, true, true, 1 *)
true = false , true || false, true && false, true >= false
, 12 < 2, "abc" <= "abd", 1 <> 2
, if true then 1 else 2
#+END_SRC

* Strings

OCaml strings are not arrays, or lists, of characters as in C or Haskell.
#+BEGIN_SRC ocaml
"string catenation" = "string " ^ "catenation"

Printf.printf "%d %s" 1972 "taxi";;
let input = read_line ();;
#+END_SRC

:More:
+ Double quotes for strings, single quote for characters,
  and a single quote may be used as part of an identifier.
  - String catenation with ~(^).~
  - Not arrays, or lists, of characters as in C or Haskell.
  - Expected ~Print.printf string args~.
  - Also ~print_string~ and ~read_line ()~.
:End:

* Records
  Records: Products with named, rather than positional, components.
#+BEGIN_SRC ocaml
  type point2d = {x : float; y : float};;
  let p = {y = 2.0; x = 3.4};; (* Construction *)
  let {x = px; y = py} = p;; (* Pattern matching for deconstruction *)
  let go {x = qx; y = qy} = qx +. qy;;
  (* More tersely, using “field pruning”: Variables must coincide with field names. *)
  let erroenous ({xx; y} : point2d )= x +. y;;
  let works {x; y} = 0.0;;
  (* Or we can use dot notation *)
  let go q = q.x +. q.y;;
#+END_SRC

* Variants and Pattern Matching
   Variant types: A unified way to combine different types into a single type;
   Each case is distinuighed by a a captialised tag.
#+BEGIN_SRC ocaml
  type fancy_num = Boring of int | AlsoBoring of float | Fancy of point2d
#+END_SRC


#+BEGIN_SRC ocaml
(* Type alias *)
type myints = int

(* Constructors must start with a capital letter, like in Haskell *)
type 'a term = Nothing | Var of 'a | Add of 'a term * 'a term
let example = Add (Var 666, Nothing)

(* Guarded pattern matching *)
let rec sum acc = function | Nothing -> 0 + (match acc with true -> 1 | false -> 0)
		       | Var x when x <= 0 -> 0
		       | (Var 666) as p -> failwith "Evil!"
		       | Add(l, r) -> sum acc l + sum acc r
		       | _ -> 2 (* Default case *)

let res = sum true example
#+END_SRC

Note that we can give a pattern a name; above we mentioned ~p~,
but did not use it.

+ Repeated & non-exhaustive patterns trigger a warning; e.g., remove the default case above.

+ You can pattern match on arrays too; e.g.,
  ~[| x ; y ; z|] -> y~.

* COMMENT Type Construction
We can make an alias: ~type myInt = int~

However we can also make a new ADT and pattern match on it.

#+BEGIN_EXAMPLE
type 'a roseTree = Leaf of 'a | MkRoseTree of 'a roseTree list

let rec treeFilter p = function
  | MkRoseTree ts   -> MkRoseTree (List.map (treeFilter p) ts)
  | Leaf a when p a -> Leaf a
  | _               -> MkRoseTree []
#+END_EXAMPLE

  - As in Haskell, constructors must start with a capital letter
   *however* type names must begin with a lowercase letter.
  - We may omit the ~of ...~ to obtain nullary constructors, as expected.

  - Notice the optional guard ~when~ and the wildcard pattern ~_~.

Example usage:
#+BEGIN_EXAMPLE
let test = MkRoseTree [ Leaf 1 ; MkRoseTree [ Leaf 2; Leaf 3] ; MkRoseTree [Leaf 4] ]

let rec even = function
 | 0 -> true
 | 1 -> false
 | n -> even (n-2)

(*
# treeFilter even test;;
- : int roseTree =
MkRoseTree
 [MkRoseTree []; MkRoseTree [Leaf 2; MkRoseTree []]; MkRoseTree [Leaf 4]]
*)
#+END_EXAMPLE

* Tuples and Lists
  Tuples: Parentheses are optional, comma is the main operator.
#+BEGIN_SRC ocaml
  let mytuple  : int * string * float = (3, "three", 3.0);;
   (* Pattern matching for tuples can also be used to extract components *)
  let (woah0, woah1, woah2) = mytuple;;
  let add_1and4 (w, x, y, z) = w + z;;

  (* Tuples: Char, String, Bool  *)
  let ys = 'a', "two", true
  let that = fst ("that", false)

  (* A singelton list of one tuple !!!!  *)
  let zs = [ 1, "two", true ]

  (* Lists:  type 'a list ≈ [] | (::) of 'a * 'a list  *)
  let xs = [1; 2; 3]
  [1; 2; 3] = 1 :: 2 :: 3 :: [];; (* Syntactic sugar *)

  (* List catenation *)
  [1;2;4;6] = [1;2] @ [4;6];;

  (* Labelled arguments, using ‘~’, means position is irrelevant in invocations *)
  [1; 2; 3] = List.map ["a", "ab", "abc"] ~f:String.length;;
  [1; 2; 3] = List.map  ~f:String.length ["a", "ab", "abc"];;

  (* Pattern matching example; Only works on lists of length 3 *)
  let go [x; y; z] = x + y + z;;
  14 = go [2;5;7];;
#+END_SRC

:More:
Then,
| List.nth list index   |
| List.map func list    |
| List.filter func list |
| List.hd               |
| List.rev              |
| List.length           |
| String.length         |

+ Syntax: ~[x₀; ...; xₙ]~

  - Tuples are optionally enclosed in parens;
    hence ~[x₀, ..., xₙ]~ is a singleton list
    consisting of only one tuple!

+ Expected functionals:
    ~List.nth~ for list lookup,
    ~List.map~, ~List.filter~, etc.

+ Cons operation is denoted ~::~.

+ Arrays have syntax ~[|x₀; ...; xₙ|]~
   with 0-indexing lookup ~arr.(n)~.

:End:

* spacing newpage                                                    :ignore:
  \newpage

* Options
Option: Expressing whether a value is present or not.
#+BEGIN_SRC ocaml
  let divide x y : int option = if y = 0 then None else Some (x / y);;
  let getInt ox = match ox with None -> 0 | Some x -> x;;
  0 = getInt None;;
  2 = getInt (Some 2);;
#+END_SRC

* Imperative programming ---arrays
Zero-indexed Arrays: Indexing with ‘.(i)’ and update with ‘<-’.
#+BEGIN_SRC ocaml
let nums : int array = [| 1; 2; 3 |];;
nums.(0) <- 12;;

(* Boolean tests *)
12 = xs_arr.(0)
[|12; 2; 3|] = nums;;

(* Operations whose use produce a side-effect return the ‘unit’ type.
 , This’ akin to the role played by ‘void’ in C. *)
let ex : unit = ();
let myupdate (arr : 'a array) (e : 'a) (i : int) : unit = arr.(i) <- e;;
myupdate nums 33 1;;
[|12; 33; 3|] = nums;;
#+END_SRC

* Sequencing

We may use begin/end or parentheses to group
expressions together.

#+BEGIN_SRC ocaml
begin
  print_string "nice";
  "bye";
  true;
  10
end

;;
(  print_string "a"
 ; () (* This is the unit value *)
 ; 9
)
;;

let x = begin 1 * 2 end + (3 - 2)
#+END_SRC

#+RESULTS:
: 3

* Imperative programming ---mutable records
Record fields are immutable by default, but can be declared mutable.
#+BEGIN_SRC ocaml
type running_sum = {mutable sum : int; mutable more : int};;
let create () = {sum = 0; more = 0};;
let update rs x =   rs.sum  <- rs.sum + rs.more
		  ; rs.more <- x;;
(* Note that ‘;’ is for Sequencing whereas ‘;;’ is for termination *)
let res = create ()
in   update res 12
   ; {sum = 0; more = 12} = res ;;
#+END_SRC

* Refs
Refs: Single mutable values; i.e., a record with a single mutable field named ‘contents’.
#+BEGIN_SRC ocaml
let x : int ref = {contents = 0};;
x.contents <- x.contents + 1;;
{contents = 1} = x;;
(* These come with a handful of convenience methods: *)
#+END_SRC

Here's their re-implementation:
#+BEGIN_SRC ocaml
(* Alias    *) type 'a ref = {mutable contents : 'a};;
(* Creation *) let ref v   = {contents = v};;
(* Access   *) let (!) r   = r.contents;; (* “value of” *)
(* Update   *) let (:=) r e = r.contents <- e;;

(* Summing the first 10 numbers *)
let sum = ref 0;;
for i = 0 to 10 do sum := !sum + i done;;
55 =  !sum;;
#+END_SRC

* Loops

At each iteration, cons the counter ~i~ to
the value of the list /so far/:
#+BEGIN_SRC ocaml
(* Using “i = 1 to 10” yields the reverse  *)
let xl = ref [] in
for i = 10 downto 1 do
xl := i :: !xl;
done;
!xl
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |

#+BEGIN_SRC ocaml
let n = 100 and i = ref 0 and x = ref 0 in
while n <> !i do
  x := !x + !i; i := !i + 1;
done;
!x , 2 * !x = n * (n - 1)
#+END_SRC

#+RESULTS:
: (4950, true)

* Reads

+ [ ] [[https://learnxinyminutes.com/docs/ocaml/][Learn x in y minutes, where x = OCaml]]
+ [ ] [[https://try.ocamlpro.com/][Try OCaml, online]]
+ [ ] [[https://realworldocaml.org/][Real World OCaml]]
+ [ ] [[http://ocaml.github.io/ocamlunix/?ref=hackr.io][Unix system programming in OCaml]]
+ [ ] [[http://mirror.ocamlcore.org/ocaml-tutorial.org/][Objective CAML Tutorial]]
+ [ ] [[https://ocaml.org/learn/tutorials/?ref=hackr.io][OCaml tutorials]]

* COMMENT Making README.md

C-c C-c: Evaluate src block.

#+NAME: make-readme
#+BEGIN_SRC elisp :results none
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.md
     #+HTML: <h1> OCamlCheatSheet </h1>
     #+OPTIONS: toc:nil d:nil
     # Toc is displayed below at a strategic position.

     Quick reference for the OCaml language.

     *The listing sheet, as PDF, can be found
     [here]({{{URL}}}/blob/master/CheatSheet.pdf)*,
     while below is an unruly html rendition.

     This reference sheet is built around the system
     https://github.com/alhassy/CheatSheet.

     #+TOC: headlines 2
     #+INCLUDE: CheatSheet.org
    ")
    (org-mode)
    (org-md-export-to-markdown)
)
#+END_SRC

* COMMENT footer

# Local Variables:
# eval: (org-babel-tangle)
# eval: (progn (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# compile-command: (org-latex-export-to-pdf)
# End:
